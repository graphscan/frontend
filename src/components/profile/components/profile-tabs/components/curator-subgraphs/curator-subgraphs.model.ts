import { ColumnType } from "antd/es/table";
import { SubgraphStates } from "../../../../../../model/subgraph-states.model";
import { divideBy1e18 } from "../../../../../../utils/number.utils";
import { isNewSubgraph } from "../../../../../../utils/subgraph.utils";
import {
  createTitleWithTooltipDescription,
  renderDeploymentId,
  renderSubgraphName,
  renderImage,
  renderFormattedValue,
  renderFormattedRealValue,
  renderOwnerId,
  renderDate,
  formatTableDate,
} from "../../../../../../utils/table.utils";

type BaseSignal = {
  id: string;
  currentGRTValue: string;
  signalledTokens: string;
  unsignalledTokens: string;
};

type Subgraph = {
  id: string;
  active: boolean;
  createdAt: number;
  metadata: {
    image: string | null;
    displayName: string | null;
  } | null;
  owner: {
    id: string;
  };
  currentVersion: {
    id: string;
    subgraphDeployment: {
      id: string;
      deniedAt: number;
      versions: Array<{
        id: string;
        subgraph: {
          id: string;
          currentVersion: {
            id: string;
          } | null;
        };
        subgraphDeployment: {
          id: string;
        };
      }>;
    };
  } | null;
};

export type NameSignal = BaseSignal & {
  nameSignal: string;
  lastNameSignalChange: number;
  subgraph: Subgraph & {
    versions: Array<{
      id: string;
      createdAt: number;
    }>;
  };
};

export type Signal = BaseSignal & {
  signal: string;
  lastSignalChange: number;
  createdAt: number;
  subgraphDeployment: {
    id: string;
    versions: Array<{
      id: string;
      subgraph: Subgraph;
    }>;
  };
};

export type CuratorSubgraphsRow = SubgraphStates & {
  id: string;
  key: string;
  img: string;
  ownerId: string;
  displayName: string;
  deploymentId: string | null;
  currentGRTValue: number;
  shares: number;
  signaledTotal: number;
  unsignaledTotal: number;
  PLGrt: number;
  lastChange: number;
  type: "Auto-Migrate" | "Deployment Signal";
  versionId: string;
};

const titles: Record<
  Exclude<
    keyof CuratorSubgraphsRow,
    "id" | "key" | "versionId" | keyof SubgraphStates
  >,
  string
> = {
  img: "Img",
  displayName: "Subgraph Name",
  ownerId: "Owner",
  deploymentId: "Deployment ID",
  type: "Signal Type",
  currentGRTValue: "Potential Signals Value",
  shares: "Shares",
  signaledTotal: "Signaled Total",
  unsignaledTotal: "Unsignaled Total",
  PLGrt: "P/L",
  lastChange: "Last Activity",
};

export const columnsWidth = {
  "2560": [62, 195, 195, 213, 185, 180, 150, 180, 180, 130, 220],
  "1920": [56, 172, 172, 177, 160, 130, 105, 130, 130, 85, 203],
  "1440": [50, 148, 148, 155, 145, 115, 90, 115, 115, 75, 180],
  "1280": [46, 130, 130, 134, 130, 102, 80, 102, 102, 65, 163],
};

export const columns: Array<ColumnType<CuratorSubgraphsRow>> = [
  {
    title: createTitleWithTooltipDescription(titles.img),
    dataIndex: "img",
    key: "img",
    render: renderImage,
  },
  {
    title: createTitleWithTooltipDescription(titles.displayName),
    dataIndex: "displayName",
    key: "displayName",
    render: renderSubgraphName("versionId"),
    onCell: () => ({
      className: "ant-table-cell_with-link ant-table-cell_left-aligned",
    }),
  },
  {
    title: createTitleWithTooltipDescription(titles.ownerId),
    dataIndex: "ownerId",
    key: "ownerId",
    align: "center",
    render: renderOwnerId,
  },
  {
    title: createTitleWithTooltipDescription(titles.deploymentId),
    dataIndex: "deploymentId",
    key: "deploymentId",
    onCell: () => ({ className: "ant-table-cell_with-link" }),
    render: renderDeploymentId(),
  },
  {
    title: createTitleWithTooltipDescription(titles.type),
    dataIndex: "type",
    key: "type",
    align: "center",
  },
  {
    title: createTitleWithTooltipDescription(
      titles.currentGRTValue,
      "Amount of GRT that can be received by Curator if unsignal from chosen subgraph.",
    ),
    dataIndex: "currentGRTValue",
    key: "currentGRTValue",
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.shares,
      `
        Shares are minted by depositing ("signaling") GRT into a subgraph's bonding curve and entitle the 
        holder to a share of the Curator commision on future query fees generated by the subgraph.
      `,
    ),
    dataIndex: "shares",
    key: "shares",
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.signaledTotal,
      "All-time amount of GRT spent on signaling on chosen subgraph.",
    ),
    dataIndex: "signaledTotal",
    key: "signaledTotal",
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.unsignaledTotal,
      "All-time amount of GRT received from unsignaling from chosen subgraph.",
    ),
    dataIndex: "unsignaledTotal",
    key: "unsignaledTotal",
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.PLGrt,
      "Unsignaled Total + Potential Signals Value - Signaled Total.",
    ),
    dataIndex: "PLGrt",
    key: "PLGrt",
    render: renderFormattedRealValue,
  },
  {
    title: createTitleWithTooltipDescription(titles.lastChange),
    dataIndex: "lastChange",
    key: "lastChange",
    align: "center",
    render: renderDate,
  },
];

type TypedNameSignal = NameSignal & {
  type: "Auto-Migrate";
};

type TypedSignal = Signal & {
  type: "Deployment Signal";
};

export const transformToRow = (
  typedSignal: TypedNameSignal | TypedSignal,
): CuratorSubgraphsRow => {
  const { id, currentGRTValue, signalledTokens, unsignalledTokens, type } =
    typedSignal;

  const currentGRTValueNum = divideBy1e18(currentGRTValue);
  const signaledTotalNum = divideBy1e18(signalledTokens);
  const unsignaledTotalNum = divideBy1e18(unsignalledTokens);

  const baseSignal = {
    id,
    type,
    currentGRTValue: currentGRTValueNum,
    signaledTotal: signaledTotalNum,
    unsignaledTotal: unsignaledTotalNum,
    PLGrt: unsignaledTotalNum + currentGRTValueNum - signaledTotalNum,
  };

  if (typedSignal.type === "Auto-Migrate") {
    const {
      id: subgraphId,
      active,
      metadata,
      owner,
      createdAt,
      currentVersion,
      versions,
    } = typedSignal.subgraph;
    const denied = currentVersion
      ? currentVersion.subgraphDeployment.deniedAt > 0
      : false;
    return {
      ...baseSignal,
      id: subgraphId,
      key: id,
      img: metadata?.image ?? "",
      displayName: metadata?.displayName ?? "",
      ownerId: owner.id,
      deploymentId: currentVersion
        ? currentVersion.subgraphDeployment.id
        : null,
      shares: divideBy1e18(typedSignal.nameSignal),
      lastChange: typedSignal.lastNameSignalChange,
      deprecated: !active || !currentVersion,
      denied,
      hasLinkedSubgraphs:
        !denied && active && currentVersion
          ? currentVersion.subgraphDeployment.versions.some(
              (x) =>
                x.subgraph.currentVersion &&
                x.subgraph.id !== subgraphId &&
                x.subgraphDeployment.id ===
                  currentVersion.subgraphDeployment.id,
            )
          : false,
      isNew: isNewSubgraph(createdAt),
      versionId:
        currentVersion?.id ??
        [...versions].sort((a, b) => b.createdAt - a.createdAt)[0].id,
    };
  }

  const { id: deploymentId, versions } = typedSignal.subgraphDeployment;

  // Handle case when there are no versions
  if (versions.length === 0) {
    return {
      ...baseSignal,
      id,
      key: id,
      img: "",
      displayName: deploymentId,
      ownerId: "",
      deploymentId,
      shares: divideBy1e18(typedSignal.signal),
      lastChange: typedSignal.lastSignalChange || typedSignal.createdAt,
      deprecated: true,
      denied: false,
      hasLinkedSubgraphs: false,
      isNew: false,
      versionId: "",
    };
  }

  const [earliestActualVersion] = versions
    .filter(
      (v) =>
        v.subgraph.currentVersion &&
        v.subgraph.currentVersion.subgraphDeployment.id === deploymentId,
    )
    .sort((a, b) => a.subgraph.createdAt - b.subgraph.createdAt);
  const [lastPastVersion] = earliestActualVersion
    ? []
    : [...versions].sort((a, b) => b.subgraph.createdAt - a.subgraph.createdAt);
  const { id: versionId, subgraph } = earliestActualVersion ?? lastPastVersion;
  const denied = subgraph.currentVersion
    ? subgraph.currentVersion.subgraphDeployment.deniedAt > 0
    : false;

  return {
    ...baseSignal,
    id,
    key: id,
    img: subgraph.metadata?.image ?? "",
    displayName: subgraph.metadata?.displayName ?? "",
    ownerId: subgraph.owner.id,
    deploymentId: subgraph.currentVersion
      ? subgraph.currentVersion.subgraphDeployment.id
      : null,
    shares: divideBy1e18(typedSignal.signal),
    lastChange: typedSignal.lastSignalChange || typedSignal.createdAt,
    deprecated: !subgraph.active || !subgraph.currentVersion,
    denied,
    hasLinkedSubgraphs:
      !denied && subgraph.active && subgraph.currentVersion
        ? subgraph.currentVersion.subgraphDeployment.versions.some(
            (x) =>
              x.subgraph.currentVersion &&
              x.subgraph.id !== subgraph.id &&
              x.subgraphDeployment.id ===
                subgraph.currentVersion?.subgraphDeployment.id,
          )
        : false,
    isNew: isNewSubgraph(subgraph.createdAt),
    versionId,
  };
};

export const transformToCsvRow = ({
  id,
  img,
  displayName,
  deploymentId,
  currentGRTValue,
  shares,
  signaledTotal,
  unsignaledTotal,
  PLGrt,
  lastChange,
}: CuratorSubgraphsRow) => ({
  [titles.img]: img,
  [titles.displayName]: displayName,
  [titles.ownerId]: id,
  [titles.deploymentId]: deploymentId,
  [titles.currentGRTValue]: currentGRTValue,
  [titles.shares]: shares,
  [titles.signaledTotal]: signaledTotal,
  [titles.unsignaledTotal]: unsignaledTotal,
  [titles.PLGrt]: PLGrt,
  [titles.lastChange]: lastChange ? formatTableDate(lastChange) : null,
});
