import { ColumnType } from 'antd/es/table';
import { SubgraphStates } from '../../../../../../model/subgraph-states.model';
import { divideBy1e18 } from '../../../../../../utils/number.utils';
import { isNewSubgraph } from '../../../../../../utils/subgraph.utils';
import {
  createTitleWithTooltipDescription,
  renderDeploymentId,
  renderSubgraphName,
  renderImage,
  renderFormattedValue,
  renderFormattedRealValue,
  renderOwnerId,
} from '../../../../../../utils/table.utils';

type BaseSignal = {
  id: string;
  currentGRTValue: string;
  signalledTokens: string;
  unsignalledTokens: string;
  PLGrt: string;
  realizedPLGrt: string;
  unrealizedPLGrt: string;
};

type Subgraph = {
  id: string;
  active: boolean;
  image: string | null;
  displayName: string | null;
  createdAt: number;
  owner: {
    id: string;
  };
  currentVersion: {
    id: string;
    subgraphDeployment: {
      id: string;
      deniedAt: number;
      versions: Array<{
        id: string;
        subgraph: {
          id: string;
          currentVersion: {
            id: string;
          } | null;
        };
        subgraphDeployment: {
          id: string;
        };
      }>;
    };
  } | null;
};

export type NameSignal = BaseSignal & {
  nameSignal: string;
  subgraph: Subgraph & {
    versions: Array<{
      id: string;
      createdAt: number;
    }>;
  };
};

export type Signal = BaseSignal & {
  signal: string;
  subgraphDeployment: {
    id: string;
    versions: Array<{
      id: string;
      subgraph: Subgraph;
    }>;
  };
};

export type CuratorSubgraphsRow = SubgraphStates & {
  id: string;
  key: string;
  img: string;
  ownerId: string;
  displayName: string;
  deploymentId: string | null;
  currentGRTValue: number;
  shares: number;
  signaledTotal: number;
  unsignaledTotal: number;
  PLGrt: number;
  realizedPLGrt: number;
  unrealizedPLGrt: number;
  type: 'Auto-Migrate' | 'Deployment Signal';
  versionId: string;
};

const titles: Record<
  Exclude<keyof CuratorSubgraphsRow, 'id' | 'key' | 'versionId' | keyof SubgraphStates>,
  string
> = {
  img: 'Img',
  displayName: 'Subgraph Name',
  ownerId: 'Owner',
  deploymentId: 'Deployment ID',
  type: 'Signal Type',
  currentGRTValue: 'Potential Signals Value',
  shares: 'Shares',
  signaledTotal: 'Signaled Total',
  unsignaledTotal: 'Unsignaled Total',
  PLGrt: 'P/L',
  realizedPLGrt: 'Realized P/L',
  unrealizedPLGrt: 'Unrealized P/L',
};

export const columnsWidth = {
  '2560': [62, 215, 215, 233, 173, 173, 173, 173, 173, 173, 173, 173],
  '1920': [56, 192, 192, 197, 132, 132, 132, 132, 132, 132, 132, 132],
  '1440': [50, 168, 168, 175, 120, 120, 120, 120, 120, 120, 120, 120],
  '1280': [46, 150, 150, 154, 105, 105, 105, 105, 105, 105, 105, 105],
};

export const columns: Array<ColumnType<CuratorSubgraphsRow>> = [
  {
    title: createTitleWithTooltipDescription(titles.img),
    dataIndex: 'img',
    key: 'img',
    render: renderImage,
  },
  {
    title: createTitleWithTooltipDescription(titles.displayName),
    dataIndex: 'displayName',
    key: 'displayName',
    render: renderSubgraphName('versionId'),
    onCell: () => ({ className: 'ant-table-cell_with-link ant-table-cell_left-aligned' }),
  },
  {
    title: createTitleWithTooltipDescription(titles.ownerId),
    dataIndex: 'ownerId',
    key: 'ownerId',
    align: 'center',
    render: renderOwnerId,
  },
  {
    title: createTitleWithTooltipDescription(titles.deploymentId),
    dataIndex: 'deploymentId',
    key: 'deploymentId',
    onCell: () => ({ className: 'ant-table-cell_with-link' }),
    render: renderDeploymentId(),
  },
  {
    title: createTitleWithTooltipDescription(titles.type),
    dataIndex: 'type',
    key: 'type',
    align: 'center',
  },
  {
    title: createTitleWithTooltipDescription(
      titles.currentGRTValue,
      'Amount of GRT that can be received by Curator if unsignal from chosen subgraph.',
    ),
    dataIndex: 'currentGRTValue',
    key: 'currentGRTValue',
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.shares,
      `
        Shares are minted by depositing ("signaling") GRT into a subgraph's bonding curve and entitle the 
        holder to a share of the Curator commision on future query fees generated by the subgraph.
      `,
    ),
    dataIndex: 'shares',
    key: 'shares',
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.signaledTotal,
      'All-time amount of GRT spent on signaling on chosen subgraph.',
    ),
    dataIndex: 'signaledTotal',
    key: 'signaledTotal',
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.unsignaledTotal,
      'All-time amount of GRT received from unsignaling from chosen subgraph.',
    ),
    dataIndex: 'unsignaledTotal',
    key: 'unsignaledTotal',
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.PLGrt,
      'Usignaled GRTs minus signaled GRT from chosen subgraph. Includes realized and unrealized P/L.',
    ),
    dataIndex: 'PLGrt',
    key: 'PLGrt',
    render: renderFormattedRealValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.realizedPLGrt,
      'Received P/L from unsignaling from chosen subgraph.',
    ),
    dataIndex: 'realizedPLGrt',
    key: 'realizedPLGrt',
    render: renderFormattedValue,
  },
  {
    title: createTitleWithTooltipDescription(
      titles.unrealizedPLGrt,
      'Potential P/L from current signals of chosen subgraphs.',
    ),
    dataIndex: 'unrealizedPLGrt',
    key: 'unrealizedPLGrt',
    render: renderFormattedValue,
  },
];

type TypedNameSignal = NameSignal & {
  type: 'Auto-Migrate';
};

type TypedSignal = Signal & {
  type: 'Deployment Signal';
};

export const transformToRow = (typedSignal: TypedNameSignal | TypedSignal): CuratorSubgraphsRow => {
  const {
    id,
    currentGRTValue,
    signalledTokens,
    unsignalledTokens,
    PLGrt,
    realizedPLGrt,
    unrealizedPLGrt,
    type,
  } = typedSignal;

  const baseSignal = {
    id,
    type,
    currentGRTValue: divideBy1e18(currentGRTValue),
    signaledTotal: divideBy1e18(signalledTokens),
    unsignaledTotal: divideBy1e18(unsignalledTokens),
    PLGrt: divideBy1e18(PLGrt),
    realizedPLGrt: divideBy1e18(realizedPLGrt),
    unrealizedPLGrt: divideBy1e18(unrealizedPLGrt),
  };

  if (typedSignal.type === 'Auto-Migrate') {
    const {
      id: subgraphId,
      active,
      image,
      displayName,
      owner,
      createdAt,
      currentVersion,
      versions,
    } = typedSignal.subgraph;
    const denied = currentVersion ? currentVersion.subgraphDeployment.deniedAt > 0 : false;
    return {
      ...baseSignal,
      id: subgraphId,
      key: id,
      img: image ?? '',
      displayName: displayName ?? '',
      ownerId: owner.id,
      deploymentId: currentVersion ? currentVersion.subgraphDeployment.id : null,
      shares: divideBy1e18(typedSignal.nameSignal),
      deprecated: !active || !currentVersion,
      denied,
      hasLinkedSubgraphs:
        !denied && active && currentVersion
          ? currentVersion.subgraphDeployment.versions.some(
              (x) =>
                x.subgraph.currentVersion &&
                x.subgraph.id !== subgraphId &&
                x.subgraphDeployment.id === currentVersion.subgraphDeployment.id,
            )
          : false,
      isNew: isNewSubgraph(createdAt),
      versionId: currentVersion?.id ?? [...versions].sort((a, b) => b.createdAt - a.createdAt)[0].id,
    };
  }

  const { id: deploymentId, versions } = typedSignal.subgraphDeployment;

  const [earliestActualVersion] = versions
    .filter(
      (v) => v.subgraph.currentVersion && v.subgraph.currentVersion.subgraphDeployment.id === deploymentId,
    )
    .sort((a, b) => a.subgraph.createdAt - b.subgraph.createdAt);
  const [lastPastVersion] = earliestActualVersion
    ? []
    : [...versions].sort((a, b) => b.subgraph.createdAt - a.subgraph.createdAt);
  const { id: versionId, subgraph } = earliestActualVersion ?? lastPastVersion;
  const denied = subgraph.currentVersion ? subgraph.currentVersion.subgraphDeployment.deniedAt > 0 : false;

  return {
    ...baseSignal,
    id,
    key: subgraph.id,
    img: subgraph.image ?? '',
    displayName: subgraph.displayName ?? '',
    ownerId: subgraph.owner.id,
    deploymentId: subgraph.currentVersion ? subgraph.currentVersion.subgraphDeployment.id : null,
    shares: divideBy1e18(typedSignal.signal),
    deprecated: !subgraph.active || !subgraph.currentVersion,
    denied,
    hasLinkedSubgraphs:
      !denied && subgraph.active && subgraph.currentVersion
        ? subgraph.currentVersion.subgraphDeployment.versions.some(
            (x) =>
              x.subgraph.currentVersion &&
              x.subgraph.id !== subgraph.id &&
              x.subgraphDeployment.id === subgraph.currentVersion?.subgraphDeployment.id,
          )
        : false,
    isNew: isNewSubgraph(subgraph.createdAt),
    versionId,
  };
};

export const transformToCsvRow = ({
  id,
  img,
  displayName,
  deploymentId,
  currentGRTValue,
  shares,
  signaledTotal,
  unsignaledTotal,
  PLGrt,
  realizedPLGrt,
  unrealizedPLGrt,
}: CuratorSubgraphsRow) => ({
  [titles.img]: img,
  [titles.displayName]: displayName,
  [titles.ownerId]: id,
  [titles.deploymentId]: deploymentId,
  [titles.currentGRTValue]: currentGRTValue,
  [titles.shares]: shares,
  [titles.signaledTotal]: signaledTotal,
  [titles.unsignaledTotal]: unsignaledTotal,
  [titles.PLGrt]: PLGrt,
  [titles.realizedPLGrt]: realizedPLGrt,
  [titles.unrealizedPLGrt]: unrealizedPLGrt,
});
